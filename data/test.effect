uniform float4x4 ViewProj;
uniform texture2d image;

uniform float4 color = {0.5, 1.0, 0.5, 1.0};  // Rectangle outline color
uniform float4 rect; // = {0.25f, 0.75f, 0.25f, 0.75f};
uniform float borderThickness = 0.001f; // Thickness of the rectangle outline

sampler_state texSampler {
    AddressU  = Clamp;
    AddressV  = Clamp;
    Filter    = Linear;
};

struct VertexInOut {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertexInOut VShader(VertexInOut vert_in)
{
    VertexInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv = vert_in.uv;
    return vert_out;
}

float4 PShader(VertexInOut fragment_in) : TARGET
{
    // Define rectangle bounds in normalized texture coordinates (0 to 1 range)
    float rectMinX = 0.25f;
    float rectMaxX = 0.75f;
    float rectMinY = 0.25f;
    float rectMaxY = 0.75f;

    // Check if the fragment is near the rectangle border
    bool isOnBorder = false;
    
    // Check if the fragment is inside the rectangle
    if ((abs(fragment_in.uv.x - rect[0]) < borderThickness || abs(fragment_in.uv.x - rect[1]) < borderThickness) && fragment_in.uv.y >= rect[2] && fragment_in.uv.y <= rect[3] ||
        (abs(fragment_in.uv.y - rect[2]) < borderThickness || abs(fragment_in.uv.y - rect[3]) < borderThickness) && fragment_in.uv.x >= rect[0] && fragment_in.uv.x <= rect[1]) {
        // If inside the rectangle, return the color
        return color;
    } else {
        // Otherwise, return the texture color
        return image.Sample(texSampler, fragment_in.uv);
    }
}

technique Draw
{
    pass
    {
        vertex_shader = VShader(vert_in);
        pixel_shader  = PShader(fragment_in);
    }
}
